{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"Introduction to Shell <p>Episodes</p> <p>1. UNIX, Linux &amp; UNIX Shell </p> <p>2. Access the Shell and Introduction to Shell Commands</p> <p>3. Introduction to Shell Commands - 2 </p> <p></p> <p>License</p> <p>Genomics Aotearoa / REANNZ \"Intermediate Shell for Bioinformatics\" is licensed under the GNU General Public License v3.0, 29 June 2007 . (Follow this link for more information)</p> <p>Attribution Notice</p> <ul> <li>This workshop material is heavily inspired by : <ol> <li>The Carpentries. The Unix Shell . https://swcarpentry.github.io/shell-novice/</li> <li>The Carpentries. Introduction to Command Line for Genomics. https://datacarpentry.org/shell-genomics/</li> </ol> </li> </ul>"},{"location":"1-intro2shell/","title":"1. UNIX, Linux &amp; UNIX Shell","text":""},{"location":"1-intro2shell/#1-unix-linux-unix-shell","title":"1. UNIX, Linux  &amp; UNIX Shell","text":"<p>Lesson Objectives</p> <ul> <li>Quick overview on UNIX operating system and it's importance</li> <li>Differences/similarities between UNIX vs. Linux</li> <li>What is a shell and the importance of UNIX shell/s for Scientific/General computing</li> <li>Types of Shell and intro to Bash Shell (we will be using the latter throughout the workshop)</li> </ul> <p></p> <p></p>"},{"location":"1-intro2shell/#the-unix-operating-system","title":"The UNIX operating system","text":"<p>Unix is a multi-user operating system which allows more than one person to use the computer resources at a time. It was originally designed as a time-sharing system to serve several users simultaneously. Unix allows direct communication with the computer via a terminal, hence being very interactive and giving the user direct control over the computer resources. Unix also gives users the ability to share data and programs among one another.</p> <p>Unix is a generic operating system which takes full advantage of all available hardware such as 32-bit processor chips, expanded memory, and large, fast hard drives. Since Unix is written in a machine-independent language (C/C++) it is portable to many different types of machines including PC's. Therefore, Unix can be adapted to meet special requirements. The UNIX operating system is made up of three parts; the kernel, the shell and the programs.</p> <p>On Unix philosophy</p> <p>\u201cAlthough that philosophy can\u2019t be written down in a single sentence, as its heart is the idea that the power of a system comes more from the relationships among programs than from the programs themselves. Many UNIX programs do quite trivial things in isolation, but, combined with other programs, become general and useful tools.\u201d \u2013 Brian Kernighan &amp; Rob Pike</p> <p>The UNIX operating system is made up of three parts; the kernel, the shell and the programs</p> <p>Kernel \u2212 The kernel is the heart of the operating system. It interacts with the hardware and most of the tasks like memory management, task scheduling and file management.</p> <p>Shell \u2212 The shell is the utility that processes your requests (acts as an interface between the user and the kernel). When you type in a command at your terminal, the shell interprets (operating as in interpreter) the command and calls the program that you want. The shell uses standard syntax for all commands. The shell recognizes a limited set of commands, and you must give commands to the shell in a way that it understands: Each shell command consists of a command name, followed by command options (if any are desired) and command arguments (if any are desired). The command name, options, and arguments, are separated by blank space. </p> <ul> <li>An interpreter operates in a simple loop: It accepts a command, interprets the command, executes the command, and then waits for another command. The shell displays a \"prompt,\" to notify you that it is ready to accept your command.  </li> </ul>"},{"location":"1-intro2shell/#unix-vs-linux","title":"UNIX vs. Linux","text":"<p>Linux is not Unix, but it is a \"Unix-like\" operating system. Linux system is derived from Unix and it is a continuation of the basis of Unix design. Linux distributions are the most famous and healthiest example of the direct Unix derivatives. BSD (Berkley Software Distribution) is also an example of a Unix derivative.</p> Unix-like &amp; a bit more on Linux <p>A Unix-like OS (also called as UN*X or *nix) is the one that works in a way similar to Unix systems, however, it is not necessary that they conform to Single UNIX Specification (SUS) or similar POSIX (Portable Operating System Interface) standard.</p> <p>SUS is a standard which is required to be met for any OS (Operating System) to qualify for using \u2018UNIX\u2019 trademark. This trademark is granted by \u2018The Open Group\u2019</p> <p>Some examples of currently registered UNIX systems include macOS, Solaris, and AIX. If we consider the POSIX system, then Linux can be regarded as Unix-like OS.</p> <p>Linux is just the kernel and not the complete OS. This Linux kernel is generally packaged in Linux distributions which thereby makes it a complete OS.</p> <p>Linux distribution (also called a distro) is an operating system that is created from a collection of software built upon the Linux Kernel and is a package management system. A standard Linux distribution consists of a Linux kernel, GNU system, GNU utilities, libraries, compiler, additional software, documentation, a window system, window manager and a desktop environment. Most of the software included in a Linux distribution is free and open source. They may include some proprietary software like binary blobs which are essential for a few device drivers.</p>"},{"location":"1-intro2shell/#unix-shell-for-scientific-computing","title":"UNIX Shell for Scientific Computing","text":"<p>A shell is a computer program that presents a command line interface which allows you to control your computer using commands entered with a keyboard instead of controlling graphical user interfaces (GUIs) with a mouse/keyboard/touchscreen combination.</p> <p>There are many reasons to learn about the shell:</p> <ul> <li>Many Scientific Computing (SC) tools can only be used through a command line interface. Many more have features and parameter options which are not available in the GUI. BLAST is an example. Many of the advanced functions are only accessible to users who know how to use a shell.</li> <li>The shell makes your work less boring. In SC you often need to repeat tasks with a large number of files. With the shell, you can automate those repetitive tasks and leave you free to do more exciting things.</li> <li>The shell makes your work less error-prone. When humans do the same thing a hundred different times (or even ten times), they\u2019re likely to make a mistake. Your computer can do the same thing a thousand times with no mistakes.</li> <li>The shell makes your work more reproducible. When you carry out your work in the command-line (rather than a GUI), your computer keeps a record of every step that you\u2019ve carried out which you can use to re-do your work when you need to. It also gives you a way to communicate unambiguously what you\u2019ve done, so that others can inspect or apply your process to new data.</li> <li>Many SC tasks require large amounts of computing power and can\u2019t realistically be run on your own machine. These tasks are best performed using remote computers or cloud computing, which can only be accessed through a shell.</li> </ul>"},{"location":"1-intro2shell/#different-types-of-shells","title":"Different Types of Shells","text":"<p>Being able to interact with the kernel makes shells a powerful tool. Without the ability to interact with the kernel, a user cannot access the utilities offered by their machine\u2019s operating system.</p> <p>Let\u2019s take a look at some of  the major shells that are available for the Linux environment</p> <p>Types of Shells</p> Bourne Shell (sh)C Shell (csh)Korn Shell (ksh)Z Shell (zsh)Fish Shell (fish) <p>Developed at AT&amp;T Bell Labs by Steve Bourne, the Bourne shell is regarded as the first UNIX shell ever. It is denoted as sh. It gained popularity due to its compact nature and high speeds of operation.</p> <p>The C shell was created at the University of California by Bill Joy. It is denoted as csh. It was developed to include useful programming features like in-built support for arithmetic operations and a syntax similar to the C programming language.</p> <p>Further, it incorporated command history which was missing in different types of shells in Linux like the Bourne shell. Another prominent feature of a C shell is \u201caliases\u201d.</p> <p>The complete path-name for the C shell is <code>/bin/csh</code>. By default, it uses the prompt <code>hostname#</code> for the root user and <code>hostname%</code> for the non-root users.</p> <p>The Korn shell was developed at AT&amp;T Bell Labs by David Korn, to improve the Bourne shell. It is denoted as ksh. The Korn shell is essentially a superset of the Bourne shell.</p> <p>Besides supporting everything that would be supported by the Bourne shell, it provides users with new functionalities. It allows in-built support for arithmetic operations while offering interactive features which are similar to the C shell.</p> <p>The Korn shell runs scripts made for the Bourne shell, while offering string, array and function manipulation similar to the C programming language. It also supports scripts which were written for the C shell. Further, it is faster than most different types of shells. </p> <p>zsh is a shell designed for interactive use, although it is also a powerful scripting language. Many of the useful features of bash, ksh, and tcsh were incorporated into zsh; many original features were added.</p> <p>Fish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. Fish supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.</p> <p>If you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then fish might be just what you\u2019re looking for!</p>"},{"location":"1-intro2shell/#type-of-shell-for-this-workshop-gnu-bourne-again-shell-bash","title":"Type of Shell for this workshop: GNU Bourne-Again shell (bash)","text":"<p>The GNU Bourne-Again shell was designed to be compatible with the Bourne shell. It incorporates useful features from different types of shells in Linux such as Korn shell and C shell.</p> <ul> <li>The shell's name bash is an acronym for \"Bourne Again Shell\", a pun on the name of the Bourne shell that it replaces and the notion of being \"born again\"</li> </ul> <p>First released in 1989, it has been used as the default login shell for most Linux distributions. Bash was also the default shell in all versions of Apple macOS prior to the 2019 release of macOS Catalina, which changed the default shell to zsh, although Bash remains available as an alternative shell</p> <p>The Bash command syntax is a superset of the Bourne shell command syntax. Bash supports brace expansion, command line completion (Programmable Completion), basic debugging and signal handling (using <code>trap</code>) among other features. Bash can execute the vast majority of Bourne shell scripts without modification, with the exception of Bourne shell scripts stumbling into fringe syntax behavior interpreted differently in Bash or attempting to run a system command matching a newer Bash builtin, etc. </p> <p>Back to homepage</p>"},{"location":"2-intro2shellcommands/","title":"2. Access the shell and Introduction to shell Commands (1)","text":""},{"location":"2-intro2shellcommands/#2-access-the-shell-and-introduction-to-shell-commands-1","title":"2. Access the shell and Introduction to shell Commands (1)","text":""},{"location":"2-intro2shellcommands/#how-to-access-the-shell","title":"How to access the shell","text":"<p>On a Mac or Linux machine, you can access a shell through a program called \u201cTerminal\u201d, which is already available on your computer. The Terminal is a window into which we will type commands. If you\u2019re using Windows, you\u2019ll need to download a separate program to access the shell.</p>"},{"location":"2-intro2shellcommands/#navigating-your-file-system","title":"Navigating your file system","text":"<p>The part of the operating system that manages files and directories is called the file system. It organizes our data into files, which hold information, and directories (also called \u201cfolders\u201d), which hold files or other directories.</p> <p>Several commands are frequently used to create, inspect, rename, and delete files and directories.</p> <p>code</p> <p>Let\u2019s find out where we are by running a command called pwd (which stands for \u201cprint working directory\u201d). At any moment, our current working directory is our current default directory, i.e., the directory that the computer assumes we want to run commands in, unless we explicitly specify something else. Here, the computer\u2019s response is /home/USERNAME</p> <pre><code>pwd\n</code></pre> output <pre><code>/home/USERNAME\n</code></pre> <p>Terminal</p> <p>Let\u2019s look at how our file system is organized. We can see what files and subdirectories are in this directory by running <code>ls</code>, which stands for \u201clisting\u201d. <code>ls</code> prints the names of the files and directories in the current directory in alphabetical order, arranged neatly into columns. We\u2019ll be working within the shell_data subdirectory, and creating new subdirectories, throughout this workshop.</p> <pre><code>ls\n</code></pre> output - may vary a bit from one computer to another. Check whether the output contains <code>shell-data</code> <pre><code>shell-data ...\n</code></pre> <p></p> <p>We can make the ls output more comprehensible by using the flag <code>-F</code>, which tells ls to add a trailing / to the names of directories:</p> <ul> <li>Anything with a \u201c<code>/</code>\u201d after it is a directory. Things with a \u201c<code>*</code>\u201d after them are programs. If there are no decorations, it\u2019s a file.</li> </ul> <pre><code>ls -l\n</code></pre> output <pre><code>shell-data/  .....\n</code></pre> <p>All commands have a lots of \"options\" similar to <code>-F</code> in <code>ls</code></p> <ul> <li>Retrieving the list of  \"options\" for a command can be done with <code>command --help</code>  ( For an example <code>ls --help</code>).  However, some command don't implement <code>--help</code> and even the ones with it might not show the full set of options. Solution for this to use <code>man</code> command ( or the modern day solution is to search online \ud83d\ude0a)</li> <li><code>man</code> (short for manual) displays detailed documentation (also referred as man page or man file) for bash commands. It is a powerful resource to explore bash commands, understand their usage and flags. Some manual files are very long. You can scroll through the file using your keyboard\u2019s down arrow or use the Space key to go forward one page and the b key to go backwards one page. When you are done reading, hit q to quit.</li> </ul> <p>Terminal</p> <p>Let\u2019s say we want to navigate to the shell-data directory we saw above. We can use the following command to get there:</p> <p></p><pre><code>cd shell-data\n</code></pre> and run <code>pwd</code> to check the the change in current working directory followed by <code>ls</code> to list the contents of that directory<p></p> <pre><code>pwd\n</code></pre> output <pre><code>/home/USER/shell-data\n</code></pre> <pre><code>ls  \n</code></pre> output <pre><code>sra_metadata  untrimmed_fastq\n</code></pre> <p>Shortcut - Tab Completion</p> <p>Typing out file or directory names can waste a lot of time and it\u2019s easy to make typing mistakes. Instead we can use tab complete as a shortcut. When you start typing out the name of a directory or file, then hit the Tab key, the shell will try to fill in the rest of the directory or file name.</p> <p>Return to your home directory and navigate back to <code>shell-data</code> with the help of Tab:</p> <pre><code>cd\n</code></pre> <ul> <li> <p><code>cd</code> command without a follow up argument will revert the working directory to <code>/home</code>directory. Same can be done with <code>cd ~</code></p> </li> <li> <p>Now enter</p> </li> </ul> <pre><code>cd she&lt;Tab&gt;/untr&lt;Tab&gt;\n</code></pre> <ul> <li>The shell will fill in the rest of the directory name for <code>shell-data</code></li> <li> <p>Using Tab complete can be very helpful. However, it will only autocomplete a file or directory name if you\u2019ve typed enough characters to provide a unique identifier for the file or directory you are trying to access.</p> </li> <li> <p>For example, if we now try to list the files which names start with <code>gen</code> by using tab complete:</p> </li> </ul> <pre><code>ls SR&lt;tab&gt;\n</code></pre> <ul> <li>The shell auto-completes your command to <code>SRR09_</code>, because all file names in the directory begin with this prefix. When you hit Tab again, the shell will list the possible choices.</li> </ul> <p>code</p> <p>So far, we have navigated to <code>shell-data</code> directory from <code>/home</code> with <code>cd</code> command and return to <code>/home</code> via the same method. What if we want to take a look at the content of <code>/home</code> directory without navigating back to it </p> <ul> <li>Confirming the current working directory is <code>/home/USER/shell-data/untrimmed_fastq</code></li> </ul> <pre><code>pwd\n</code></pre> <ul> <li>use <code>ls ..</code> command where <code>..</code> represents \"one step up\"</li> </ul> <pre><code>ls ..\n</code></pre>"},{"location":"2-intro2shellcommands/#copying-renaming-removing-files-and-creating-directories","title":"Copying, renaming, removing files and creating directories","text":"<p>Terminal</p> <ul> <li> <p>Confirm the current working directory is <code>/home/USER/shell-data/untrimmed_fastq</code></p> </li> <li> <p>Let's create a sub-directory within the <code>..shell-data</code> directory and name it <code>backup</code>. This can be done with the <code>mkdir</code> command</p> </li> </ul> <p></p><pre><code>mkdir backup\n</code></pre> - List the content of the current directory with <code>ls -F</code> to make sure the directory was created <p></p> <pre><code>ls -F\n</code></pre> output <pre><code>backup/  SRR097977.fastq*  SRR098026.fastq*\n</code></pre> <ul> <li>create a copy of <code>SRR097977.fastq</code> file and name it <code>SRR097977.fastq.backup</code></li> </ul> <pre><code>cp SRR097977.fastq SRR097977.fastq.backup\n</code></pre> <ul> <li>\"move\" <code>SRR097977.fastq.backup</code> file to <code>backup/</code> directory  with <code>mv</code> command </li> </ul> <pre><code>mv SRR097977.fastq.backup backup/\n</code></pre> <ul> <li>Check the content of <code>backup/</code> directory with <code>ls</code> </li> </ul> <pre><code>ls backup/\n</code></pre> <ul> <li>Delete the file in backup directory </li> </ul> <pre><code>rm backup/SRR097977.fastq.backup\n</code></pre> <p>Check whether you can delete the <code>backup/</code> directory with <code>rm</code> command</p>"},{"location":"3-intro2shellcommands/","title":"3. Introduction to shell Commands (2)","text":""},{"location":"3-intro2shellcommands/#3-introduction-to-shell-commands-2","title":"3. Introduction to shell Commands (2)","text":""},{"location":"3-intro2shellcommands/#examining-file-content","title":"Examining file content\u00b6","text":"<p>Terminal</p> <p>There are a number of ways to examine the content of a file. <code>cat</code> and <code>less</code> are two commonly used programs for a quick look. Check the content of SRR097977.fastq by using these commands. Take a note of the differences.</p> <ul> <li>Take a look at the content of <code>gen360_1.tsv</code> with <code>cat</code> command as below</li> </ul> <pre><code>cat SRR097977.fastq\n</code></pre> <ul> <li><code>cat</code> command will print the content of the file to display . This is not convenient for files with a lot of rows as it Terminals in their default settings will not allow us to scroll all the way back to the top. Using <code>less</code> command is slightly better</li> </ul> <pre><code>less SRR097977.fastq\n</code></pre> <ul> <li>Use Up and Down arrow keys to navigate in <code>less</code> output</li> </ul> <p></p><p></p> <ul> <li>What if we want to take a look at the \"beginning\" (<code>head</code>) or just the \"end\"(<code>tail</code>) of the file</li> </ul> <p></p><pre><code>head SRR097977.fastq\n</code></pre> <pre><code>tail SRR097977.fastq\n</code></pre><p></p> <ul> <li><code>head</code> and <code>tail</code>command will print top and bottom 10 lines, respectively. </li> <li>What If we want to take a look at top 15 lines ? . Both <code>head</code> and <code>tail</code> commands have a <code>-n</code> (number of lines) which allows us to over-ride the default</li> </ul> <p></p><pre><code>head -n 15 SRR097977.fastq\n</code></pre> <pre><code>tail -n 15 SRR097977.fastq\n</code></pre><p></p>"},{"location":"3-intro2shellcommands/#doesnt-require-a-full-view-just-want-to-count-the-number-of-lines","title":"Doesn't require a full \"view\", just want to count the number of lines ?","text":"<p>Terminal</p> <ul> <li><code>wc</code> (short for word count) is a command line tool in Unix/Linux operating systems, which is used to find out the number of newline count, word count, byte and character count in the files specified</li> </ul> <pre><code>wc SRR097977.fastq\n</code></pre> output <pre><code>996  1992 47552 SRR097977.fastq\n</code></pre> <ul> <li><code>996</code> : Number of lines </li> <li><code>1992</code> : Number of Words</li> <li><code>47552</code> : Number of bytes</li> </ul> Run <code>wc</code> command with <code>-l</code> , <code>-w</code> and <code>-m</code>  options against the <code>SRR097977.fastq</code> file and review the outputs ?"},{"location":"3-intro2shellcommands/#redirection-and-extraction","title":"Redirection and extraction\u00b6","text":"<p>Terminal</p> <ul> <li>Although using <code>cat</code> and <code>less</code> commands will allow us to view the content of the whole file, most of the time we are in search of particular characters (strings) of interest, rather than the full content of the file. One of the most commonly used command-line utilities to search for strings is <code>grep</code>. Let's use this command to search for the string EUR  in <code>gen360_1.tsv</code> file.</li> </ul> <pre><code>grep NNNNNNNNNN SRR098026.fastq\n</code></pre> <ul> <li>We can think of <code>grep</code> as a \"extremely\" powerful \"search\" command</li> <li>Running <code>grep NNNNNNNNNN SRR098026.fastq</code> printed the output to terminal which is not reliable during when we have to revise or re-use. In order for \"string\" of interest to be used for other operations, this has to be \"redirected\" (captured and written into a file). The command for redirecting output to a file is <code>&gt;</code>. Redirecting the string of <code>EUR</code> that was searched using the grep command to a file <code>eur.txt</code> can be done with</li> </ul> <pre><code>grep grep NNNNNNNNNN SRR098026.fastq &gt; badreads.txt\n</code></pre> <ul> <li>In other words, <code>&gt;</code> operates as a <code>Save</code> command</li> </ul>"},{"location":"3-intro2shellcommands/#loops","title":"Loops","text":"<p>Loops are a common concept in most programming languages which allow us to execute commands repeatedly with ease. Using loops also reduces the amount of typing (and typing mistakes). Loops are helpful when performing operations on groups </p> <p>Therefore three basic loop constructs in <code>bash</code> scripting, <code>for</code> , <code>while</code> and <code>until</code></p> <p>Let's take a quick look at <code>for</code> loop</p> <ul> <li><code>shell-data/untrimmed_fastq</code> directory has two .tsv files</li> <li>Let's say we want to take a look at the top four lines of both files, <ul> <li>We can use <code>head</code> command with <code>-n 4</code> option and execute it to two files separately as below</li> </ul> </li> </ul> <p></p><pre><code>head -n 4 SRR097977.fastq\n</code></pre> <pre><code>head -n 4 SRR098026.fastq\n</code></pre><p></p> <ul> <li>Not so much of any issue where it's one or two files but not very convenient when we have to deal with tens or hundreds or thousands. We can use a <code>for</code> loop to execute this recursive task by using a \"common\" factor in filename ( or other attributes) .i.e. <ul> <li>Identify and isolate the files by using a common factor. In this instance, we will use <code>.fastq</code> file extension</li> <li>Then assign the values ( filenames) of those files to what is known as a control variable </li> <li>apply the command to control variable which is holding the values ( In this instance, file names)</li> </ul> </li> <li>Constructing the <code>for</code> loop<ul> <li>Always starts with <code>for</code>  (When the shell sees the keyword <code>for</code>, it knows to repeat a command (or group of commands) once for each item in a list)</li> <li>control varialble holding the filenames will be <code>filename</code> ( this can be anything we want. )</li> </ul> </li> </ul> <pre><code>for filename in *.fastq\ndo\n    head -n 4 ${filename}\ndone\n</code></pre> output <pre><code>@SRR097977.1 209DTAAXX_Lenski2_1_7:8:3:710:178 length=36\nTATTCTGCCATAATGAAATTCGCCACTTGTTAGTGT\n+SRR097977.1 209DTAAXX_Lenski2_1_7:8:3:710:178 length=36\nCCCCCCCCCCCCCCC&gt;CCCCC7CCCCCCACA?5A5&lt;\n@SRR098026.1 HWUSI-EAS1599_1:2:1:0:968 length=35\nNNNNNNNNNNNNNNNNCNNNNNNNNNNNNNNNNNN\n+SRR098026.1 HWUSI-EAS1599_1:2:1:0:968 length=35\n!!!!!!!!!!!!!!!!#!!!!!!!!!!!!!!!!!!\n</code></pre>"}]}